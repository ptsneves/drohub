using System;
using System.Net;
using System.Threading.Tasks;
using System.Threading;
using Thrift.Transport;
using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift;
namespace DroHub.Helpers.Thrift
{
    public class TAMessageValidatorProtocol : TProtocolDecorator
    {
        /**
        * TMessageValidatorProtocol is a protocol-independent concrete decorator that allows a Thrift
        * client to communicate with a Server and validate that the messaged received is matching the
        * sent seqid. If it does not match we keep reading the buffer or throw an exception.
        * This Protocol Decorator provides the most advantage with a framed transport.
        * By default Thrift processors only provide an incrementing seqid that always starts in 0,
        * which can lead to collisions when 2 protocols are started at the same time over the same
        * transport.
        * To mitigate that this protocol also overrides the seqid normally generated by the processor,
        * because it uses a random seq id to avoid shared channel seqid collisions.
        */
        private const int _MAGIC_NUMBER = 21474347;
        private int _random_seq_id;
        private string _message_name;
        public enum ValidationModeEnum
        {
            KEEP_READING,
            THROW_EXCEPTION
        }
        public enum OperationModeEnum
        {
            SEQID_SLAVE,
            SEQID_MASTER
        }
        public ValidationModeEnum ValidationMode { get; set; }
        public OperationModeEnum OperationMode{ get;}
    public TAMessageValidatorProtocol(TProtocol protocol, ValidationModeEnum validation_mode, OperationModeEnum operation_mode)
            : base(protocol)
        {
            ValidationMode = validation_mode;
            OperationMode = operation_mode;
            var rand = new Random();
            _random_seq_id = rand.Next();
        }

        public class Factory: TProtocolFactory {
            private readonly ValidationModeEnum _validation_mode;
            private readonly OperationModeEnum _operation_mode;
            private readonly TProtocolFactory _protocol_factory;
            public Factory(TProtocolFactory protocol_factory, ValidationModeEnum validation_mode, OperationModeEnum
            operation_mode) {
                _protocol_factory = protocol_factory;
                _validation_mode = validation_mode;
                _operation_mode = operation_mode;
            }
            public override TProtocol GetProtocol(TTransport transport)
            {
                return new TAMessageValidatorProtocol(_protocol_factory.GetProtocol(transport), _validation_mode,
                _operation_mode);
            }
        }
        private async Task ReadMagicNumber(CancellationToken cancellationToken)
        {
            byte[] HeaderBuffer = new byte[1];
            int result = 0;
            do
            {
                var d = await Trans.ReadAllAsync(HeaderBuffer, 0, 1, cancellationToken);
                result = result << 8 | HeaderBuffer[0];
                // Console.WriteLine($"buffer read {d} {string.Format("0x{0:X}",HeaderBuffer[0] )} in {HeaderBuffer[0]}-> {result} or {_MAGIC_NUMBER} == {result == _MAGIC_NUMBER}");
            } while (!cancellationToken.IsCancellationRequested && result != _MAGIC_NUMBER);
        }
        private async Task WriteMagicNumber(CancellationToken cancellationToken) {
            var bytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(_MAGIC_NUMBER));
            await Trans.WriteAsync(bytes, 0, 4, cancellationToken);
        }
        public override async Task WriteMessageBeginAsync(TMessage message, CancellationToken cancellationToken)
        {
            switch (OperationMode) {
                case OperationModeEnum.SEQID_MASTER:
                    _random_seq_id++;
                    message.SeqID = _random_seq_id;
                    _message_name = message.Name;
                    break;
                case OperationModeEnum.SEQID_SLAVE:
                    break;
                default:
                    throw new TProtocolException(TProtocolException.NOT_IMPLEMENTED, "Invalid operation mode selected");
            }

            await WriteMagicNumber(cancellationToken);
            await base.WriteMessageBeginAsync(message, cancellationToken);
        }
        public override async ValueTask<TMessage> ReadMessageBeginAsync(CancellationToken cancellationToken)
        {
            await ReadMagicNumber(cancellationToken);
            var new_message = await base.ReadMessageBeginAsync(cancellationToken);
            // Console.WriteLine($"seq id {_random_seq_id} == {new_message.SeqID}");
            if (OperationMode != OperationModeEnum.SEQID_MASTER)
                return new_message;

            while (_random_seq_id != new_message.SeqID && _message_name != new_message.Name) {
                switch (ValidationMode) {
                    case ValidationModeEnum.KEEP_READING:
                        await ReadMagicNumber(cancellationToken);
                        new_message = await base.ReadMessageBeginAsync(cancellationToken);
                        break;
                    case ValidationModeEnum.THROW_EXCEPTION:
                        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "Received SeqID and sent one do not match.");
                    default:
                        throw new InvalidProgramException("This is an unreachable situation");
                }
            }
            return new_message;
        }
    }
}